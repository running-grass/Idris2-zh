# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020-2023, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 09:52+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/ffi/ffi.rst:5
#: 7055e93819f84cb1b5e7c7237542ee35
msgid "FFI Overview"
msgstr ""

#: ../source/ffi/ffi.rst:7
#: 4915985777804bdd9b5aec7af2418fdc
msgid "Foreign functions are declared with the ``%foreign`` directive, which takes the following general form:"
msgstr ""

#: ../source/ffi/ffi.rst:15
#: 7fb92f54a4b449a9a27a9ccbaa52dcef
msgid "The specifier is an Idris ``String`` which says in which language the foreign function is written, what it's called, and where to find it. There may be more than one specifier, and a code generator is free to choose any specifier it understands - or even ignore the specifiers completely and use their own approach. In general, a specifier has the form \"Language:name,library\". For example, in C:"
msgstr ""

#: ../source/ffi/ffi.rst:27
#: 7a9f1a15d8bb498ea4cdb59ab1d155af
msgid "It is up to specific code generators to decide how to locate the function and the library. In this document, we will assume the default Chez Scheme code generator (the examples also work with the Racket or Gambit code generator) and that the foreign language is C."
msgstr ""

#: ../source/ffi/ffi.rst:32
#: 0857798b2aeb41f9a25b5485ed53a97a
msgid "FFI declarations for C functions can also, optionally, take a C header file to be ``#include``'d in the C code generated by the Idris2 compiler. For instance:"
msgstr ""

#: ../source/ffi/ffi.rst:40
#: e8892949f00743489f0abbba36ab3c59
msgid "FFI declarations can be extended in another file with the ``%foreign_impl`` pragma. This pragma can be used to fill in cases not handled in the standard library when using third party backends. In the case of multiple declarations for a given backend the one from the last module loaded is used."
msgstr ""

#: ../source/ffi/ffi.rst:50
#: a77863ef63f64d8c9bb172af16f5854c
msgid "Scheme Details"
msgstr ""

#: ../source/ffi/ffi.rst:52
#: 056f42869c314c2988e61d16955d4c2a
msgid "Scheme foreign specifiers can be written to target particular flavors."
msgstr ""

#: ../source/ffi/ffi.rst:54
#: 595bc5bd7a6544e8b38b503cde812174
msgid "The following example shows a foreign declaration that allocates memory in a way specific to the choice of code generator. In this example there is no general scheme specifier present that matches every flavor, e.g. ``scheme:foo``, so it  will only match the specific flavors listed:"
msgstr ""

#: ../source/ffi/ffi.rst:67
#: 34b37cfe1638482e856a84a38dbe3246
msgid "If your backend (code generator) is not specified but defines a C FFI it will be able to make use of the ``C:malloc,libc`` specifier."
msgstr ""

#: ../source/ffi/ffi.rst:71
#: bb942fa22ac44058bb9dc6e51df37763
msgid "C Sidenote"
msgstr ""

#: ../source/ffi/ffi.rst:73
#: 66cfcacf341d44c9b053e752013bdbd9
msgid "The ``C`` language specifier is used for common functions that may be used by any backend which can, in turn, FFI out to C. For example, Scheme."
msgstr ""

#: ../source/ffi/ffi.rst:76
#: b0b89ee6f72847c6be7d9e98bb2677a4
msgid "The common C functions do no automatic memory management, deferring that to the individual backends."
msgstr ""

#: ../source/ffi/ffi.rst:79
#: 157a7f4c64944559a76fc7a542efa38e
msgid "The standard C backend is known as \"RefC\", and uses the ``RefC`` language specifier."
msgstr ""

#: ../source/ffi/ffi.rst:83
#: 0b7438eb3c49422b8572349a0ac3ce9d
msgid "Javascript Details"
msgstr ""

#: ../source/ffi/ffi.rst:85
#: 940283108fd641d7955ef503dd26cad2
msgid "Javascript foreign specifiers can be written to target ``browser``, ``node``, or ``javascript``. The former two are mutually exclusive while ``javascript`` FFI specifiers apply both when building for the browser and when building for NodeJS."
msgstr ""

#: ../source/ffi/ffi.rst:90
#: e297e972654d41899f4f50b44db5c13d
msgid "Javascript specifiers must be further specialized as ``lambda``, ``support``, or ``stringIterator``."
msgstr ""

#: ../source/ffi/ffi.rst:93
#: cb18621b3c3d4f41989545e1fa088545
msgid "The syntax, therefore, is ``node:lambda:some_func`` (for the NodeJS-specific FFI and a lambda that executes a function named ``some_func``)."
msgstr ""

#: ../source/ffi/ffi.rst:96
#: 927995a444cb45cea49db15fe83195ce
msgid "When using the ``support`` option, you also specify the name of the support file. Idris will look in all ``data`` directories under a ``js`` subfolder for a file with this name. These file names should be distinct for your project so they don't collide with support files from other projects further on in the build process for an executable. Suppose your package is named \"http-idris\" and you have FFI specifiers like ``node:support:http_request,http_idris`` in your Idris code. You should make sure a data directory in scope has a ``js`` directory with an ``http_idris.js`` file in it. Another important note is that functions within this file must be prefixed with ``http_idris_``; therefore, the function referred to in the example we give here would need to be named ``http_idris_http_request`` in the ``http_idris.js`` support file."
msgstr ""

#: ../source/ffi/ffi.rst:110
#: 157cb9e6caee45bf853c31e4977e05d6
msgid "FFI Example"
msgstr ""

#: ../source/ffi/ffi.rst:112
#: 51a63571a3e64f42b72c55998107fae1
msgid "As a running example, we are going to work with a small C file. Save the following content to a file ``smallc.c``"
msgstr ""

#: ../source/ffi/ffi.rst:128
#: e8415e56c3a24d6ba84d02972ed7a185
msgid "Then, compile it to a shared library with::"
msgstr ""

#: ../source/ffi/ffi.rst:132
#: 434c538964fd4339966ca3814de0d91b
msgid "We can now write an Idris program which calls each of these. First, we'll write a small program which uses ``add`` to add two integers:"
msgstr ""

#: ../source/ffi/ffi.rst:143
#: a21a8385e7d044b3ab776416a93093ad
msgid "The ``%foreign`` declaration states that ``add`` is written in C, with the name ``add`` in the library ``libsmall``. As long as the run time is able to locate ``libsmall.so`` (in practice it looks in the current directory and the system library paths) we can run this at the REPL:"
msgstr ""

#: ../source/ffi/ffi.rst:153
#: 15f06f94555845308461e371f3550bca
msgid "Note that it is the programmer's responsibility to make sure that the Idris function and C function have corresponding types. There is no way for the machine to check this! If you get it wrong, you will get unpredictable behaviour."
msgstr ""

#: ../source/ffi/ffi.rst:158
#: bef35666e4a24650acf8820b63264ad8
msgid "Since ``add`` has no side effects, we've given it a return type of ``Int``. But what if the function has some effect on the outside world, like ``addWithMessage``? In this case, we use ``PrimIO Int`` to say that it returns a primitive IO action:"
msgstr ""

#: ../source/ffi/ffi.rst:168
#: 5035e98bc99e4dd8ba5e6832d8d98a58
msgid "Internally, ``PrimIO Int`` is a function which takes the current (linear) state of the world, and returns an ``Int`` with an updated state of the world. In general, ``IO`` operations in an Idris program are defined as instances of the ``HasIO`` interface. We can convert a primitive operation to one usable in ``HasIO`` using ``primIO``:"
msgstr ""

#: ../source/ffi/ffi.rst:178
#: e4a3060eb8d74436943d4e52fe0c6f7f
msgid "So, we can extend our program as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:191
#: ccade07822ae4f32af5d227f5183ee16
msgid "It is up to the programmer to declare which functions are pure, and which have side effects, via ``PrimIO``. Executing this gives:"
msgstr ""

#: ../source/ffi/ffi.rst:200
#: a665a6ad8e2946bcb291ce2ea40dd92c
msgid "We have seen two specifiers for foreign functions:"
msgstr ""

#: ../source/ffi/ffi.rst:207
#: dedde9c5b8284da7b7fe440bbb37a663
msgid "These both have the same form: ``\"C:[name],libsmall\"`` so instead of writing the concrete ``String``, we write a function to compute the specifier, and use that instead:"
msgstr ""

#: ../source/ffi/ffi.rst:225
#: af73dd3975e942faaa0ddd43b47d5f05
msgid "Primitive FFI Types"
msgstr ""

#: ../source/ffi/ffi.rst:227
#: 787ecedaf36d4adeb278a867ee1dc74c
msgid "The types which can be passed to and returned from foreign functions are restricted to those which it is reasonable to assume any back end can handle. In practice, this means most primitive types, and a limited selection of others.  Argument types can be any of the following primitives:"
msgstr ""

#: ../source/ffi/ffi.rst:232
#: ../source/ffi/ffi.rst:464
#: 6fff0d7b770747329418623ca45b3a24
#: 3c637c1482d1428ba531b4537c11825a
msgid "``Int``"
msgstr ""

#: ../source/ffi/ffi.rst:233
#: ../source/ffi/ffi.rst:465
#: 8ee7ba94e0b14df7ad9126a4ba4a49cb
#: 3d3603d7287f483d84619ad48ad5d19f
msgid "``Char``"
msgstr ""

#: ../source/ffi/ffi.rst:234
#: fade2e77fd1041508054c5abb01ad752
msgid "``Double`` (as ``double`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:235
#: ../source/ffi/ffi.rst:467
#: 5afcaafa9d1841d89afc048c712afeba
#: 56bf7000a8bb4c67bdaa5aded4cc2b18
msgid "``Bits8``"
msgstr ""

#: ../source/ffi/ffi.rst:236
#: ../source/ffi/ffi.rst:468
#: 3ba435c3966d47f6a1f5d28109046e15
#: 2636362c903f406a9d6ec3d3de186534
msgid "``Bits16``"
msgstr ""

#: ../source/ffi/ffi.rst:237
#: ../source/ffi/ffi.rst:469
#: 326612bbe49c4e598488c698d529da56
#: 16c421884d5f48be8a5598a90054f4ab
msgid "``Bits32``"
msgstr ""

#: ../source/ffi/ffi.rst:238
#: ../source/ffi/ffi.rst:470
#: 0da066574e04466793883f29d292fd4b
#: 1fbe7c268de24f0995c17196f3690b95
msgid "``Bits64``"
msgstr ""

#: ../source/ffi/ffi.rst:239
#: 4bb8e18712dd45cbabfc9c4900c6b67f
msgid "``String`` (as ``char*`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:240
#: 2f2119e68c724e048668f038997240a0
msgid "``Ptr t`` and ``AnyPtr`` (both as ``void*`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:242
#: 1aefb0e0504248ebbd470a47dd8b7cb3
msgid "Return types can be any of the above, plus:"
msgstr ""

#: ../source/ffi/ffi.rst:244
#: 59fb023bd1594c0d9622dfccddeb9050
msgid "``()``"
msgstr ""

#: ../source/ffi/ffi.rst:245
#: 999eca9b86154687bee5275ea0196ba8
msgid "``PrimIO t``, where ``t`` is a valid return type other than a ``PrimIO``."
msgstr ""

#: ../source/ffi/ffi.rst:247
#: 4c323f7cd96640c49986adeb1a473612
msgid "Handling ``String`` leads to some complications, for a number of reasons:"
msgstr ""

#: ../source/ffi/ffi.rst:249
#: 1635c5b6ccad47b4a0c443f70f919656
msgid "Strings can have multiple encodings. In the Idris run time, Strings are encoded as UTF-8, but C makes no assumptions."
msgstr ""

#: ../source/ffi/ffi.rst:251
#: f95731b3e4674d649250d7a5fd2bb96a
msgid "It is not always clear who is responsible for freeing a ``String`` allocated by a C function."
msgstr ""

#: ../source/ffi/ffi.rst:253
#: d6ae607918b448f3a9d5e75ab5d50540
msgid "In C, strings can be ``NULL``, but Idris strings always have a value."
msgstr ""

#: ../source/ffi/ffi.rst:255
#: 6404b48fc5914408a84ca6eb6cb7e090
msgid "So, when passing ``String`` to and from C, remember the following:"
msgstr ""

#: ../source/ffi/ffi.rst:257
#: f63a06a7f4d340128b104cf595f7d33d
msgid "A ``char*`` returned by a C function will be copied to the Idris heap, and the Idris run time immediately calls ``free`` with the returned ``char*``."
msgstr ""

#: ../source/ffi/ffi.rst:259
#: 584d1a7aa1704e78be97cf17f1330a6f
msgid "If a ``char*`` might be ``NULL`` in ``C``, use ``Ptr String`` rather than ``String``."
msgstr ""

#: ../source/ffi/ffi.rst:262
#: 5e006f82be934d1da8cce5d6318eb006
msgid "When using ``Ptr String``, the value will be passed as a ``void*``, and therefore not accessible directly by Idris code. This is to protect against accidentally trying to use ``NULL`` as a ``String``. You can nevertheless work with them and convert to ``String`` via foreign functions of the following form:"
msgstr ""

#: ../source/ffi/ffi.rst:282
#: 7fcbff0f158d48dc8d08cf596995d9e3
msgid "For an example, see the sample :ref:`sect-readline` bindings."
msgstr ""

#: ../source/ffi/ffi.rst:284
#: 0fc38d9110f248a0bc3d052e0f8aa365
msgid "Additionally, foreign functions can take *callbacks*, and take and return C ``struct`` pointers."
msgstr ""

#: ../source/ffi/ffi.rst:290
#: 0a3ad4da202e430d90d5035a4672a394
msgid "Callbacks"
msgstr ""

#: ../source/ffi/ffi.rst:292
#: 319be42e1e464e7f9aa55ff3d9280ec8
msgid "It is often useful in C for a function to take a *callback*, that is a function which is called after doing some work. For example, we can write a function which takes a callback that takes a ``char*`` and an ``int`` and returns a ``char*``, in C, as follows (added to ``smallc.c`` above):"
msgstr ""

#: ../source/ffi/ffi.rst:306
#: e1c096c2e26e4aa5a0637a0ff257c651
msgid "Then, we can access this from Idris by declaring it as a ``%foreign`` function and wrapping it in the ``HasIO`` interface, with the C function calling the Idris function as the callback:"
msgstr ""

#: ../source/ffi/ffi.rst:319
#: 8bf557dab5ce44cb9a4401b98ad12a97
msgid "For example, we can try this as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:337
#: 8facb30165bc4d19aac5798de13597aa
msgid "As a variant, the callback could have a side effect:"
msgstr ""

#: ../source/ffi/ffi.rst:345
#: f1874f6b378f4cbea0d037645288ba2d
msgid "This is a little more fiddly to lift to a ``HasIO`` function, due to the callback, but we can do so using ``toPrim : IO a -> PrimIO a``:"
msgstr ""

#: ../source/ffi/ffi.rst:354
#: d0d55a9c7cb0403a905659685ed381c9
msgid "Note that the callback is explicitly in ``IO`` here, since ``HasIO`` doesn't have a general method for extracting the primitive ``IO`` operation."
msgstr ""

#: ../source/ffi/ffi.rst:357
#: e33e125c2ca7445192959eca18e6dc18
msgid "For example, we can extend the above ``pluralise`` example to print a message in the callback:"
msgstr ""

#: ../source/ffi/ffi.rst:378
#: f91d49a06f6d4b26a7fd7e5fec2e1aa4
msgid "Structs"
msgstr ""

#: ../source/ffi/ffi.rst:380
#: 627cb80d1ee94015b7262d3424c9412e
msgid "Many C APIs pass around more complex data structures, as a ``struct``. We do not aim to be completely general in the C types we support, because this will make it harder to write code which is portable across multiple back ends. However, it is still often useful to be able to access a ``struct`` directly. For example, add the following to the top of ``smallc.c``, and rebuild ``libsmall.so``:"
msgstr ""

#: ../source/ffi/ffi.rst:407
#: c0d2c8f788984ea6a5ace3fb74aacb07
msgid "We can define a type for accessing ``point`` in Idris by importing ``System.FFI`` and using the ``Struct`` type, as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:424
#: 47a57b10a5f14334ae056a62350530f4
msgid "The ``Point`` type in Idris now corresponds to ``point*`` in C."
msgstr ""

#: ../source/ffi/ffi.rst:426
#: 3bac482076744d7ab53f306c9a3af8b0
msgid "**Important**: ``Struct`` types must define all fields of the C ``struct``. Partial definitions will fail with memory access errors."
msgstr ""

#: ../source/ffi/ffi.rst:429
#: fe3eff206ee34dc188108c29711e205c
msgid "Fields can be read and written using the following, also from ``System.FFI``:"
msgstr ""

#: ../source/ffi/ffi.rst:438
#: a091d3c08cea452e8d882d1fa5e04e6a
msgid "Notice that fields are accessed by name, and must be available in the struct, given the constraint ``FieldType n ty fs``, which states that the field named ``n`` has type ``ty`` in the structure fields ``fs``. So, we can display a ``Point`` as follows by accessing the fields directly:"
msgstr ""

#: ../source/ffi/ffi.rst:451
#: 0112d7d374024aa9bc6f7fe21e486ef1
msgid "And, as a complete example, we can initialise, update, display and delete a ``Point`` as follows:"
msgstr ""

#: ../source/ffi/ffi.rst:462
#: 3cb1297d85a141a6be68869cfe4e1bb6
msgid "The field types of a ``Struct`` can be any of the following:"
msgstr ""

#: ../source/ffi/ffi.rst:466
#: 78b04fb92dcc489498db8e63f281bac3
msgid "``Double`` (``double`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:471
#: f9527d196b024e9eb9bfc420c4cbfeab
msgid "``Ptr a`` or ``AnyPtr`` (``void*`` in C)"
msgstr ""

#: ../source/ffi/ffi.rst:472
#: 479cd94b074d4c5fb7e9291d716abed4
msgid "Another ``Struct``, which is a pointer to a ``struct`` in C"
msgstr ""

#: ../source/ffi/ffi.rst:474
#: 823b891aa44249f780402d14fc796468
msgid "Note that this doesn't include ``String`` or function types! This is primarily because these aren't directly supported by the Chez back end. However, you can use another pointer type and convert. For example, assuming you have, in C:"
msgstr ""

#: ../source/ffi/ffi.rst:485
#: a76515d8352f4b42a99f71db073b0b98
msgid "You can represent this in Idris as:"
msgstr ""

#: ../source/ffi/ffi.rst:495
#: 8fc934eb387b4768ab578899f57769f4
msgid "That is, using a ``Ptr String`` instead of a ``String`` directly. Then you can convert between a ``void*`` and a ``char*`` in C:"
msgstr ""

#: ../source/ffi/ffi.rst:504
#: ee4941d8e0db4ecb9deafece6f50b298
msgid "...and use this to convert to a ``String`` in Idris:"
msgstr ""

#: ../source/ffi/ffi.rst:513
#: bb40a4c556e84ccbb59ca3fbd9653a30
msgid "Finalisers"
msgstr ""

#: ../source/ffi/ffi.rst:515
#: 9721b30a4820490697c976fa6a03677e
msgid "In some libraries, a foreign function creates a pointer and the caller is responsible for freeing it. In this case, you can make an explicit foreign call to ``free``. However, this is not always convenient, or even possible. Instead, you can ask the Idris run-time to be responsible for freeing the pointer when it is no longer accessible, using ``onCollect`` (or its typeless variant ``onCollectAny``) defined in the Prelude:"
msgstr ""

#: ../source/ffi/ffi.rst:527
#: a17abcee40ea483e938082daf9bc78e1
msgid "A ``GCPtr t`` behaves exactly like ``Ptr t`` when passed to a foreign function (and, similarly, ``GCAnyPtr`` behaves like ``AnyPtr``). A foreign function cannot return a ``GCPtr`` however, because then we can no longer assume the pointer is completely managed by the Idris run-time."
msgstr ""

#: ../source/ffi/ffi.rst:532
#: 5ac0365deae145a79b6e69bb3b256d3f
msgid "The finaliser is called either when the garbage collector determines that the pointer is no longer accessible, or at the end of execution."
msgstr ""

#: ../source/ffi/ffi.rst:535
#: 69ddd9f9c6c64d1faffe21de29a24fd9
msgid "Note that finalisers might not be supported by all back ends, since they depend on the facilities offered by a specific back end's run time system. They are certainly supported in the Chez Scheme and Racket back ends."
msgstr ""
