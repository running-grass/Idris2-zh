# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020-2023, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 09:52+0800\n"
"PO-Revision-Date: 2022-09-03 13:48+0000\n"
"Last-Translator: grass <hi@grass.show>\n"
"Language-Team: Chinese (Simplified) <>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../source/tutorial/modules.rst:5 acb2441d200647a68a0164f85f8f8f84
msgid "Modules and Namespaces"
msgstr "模块和命名空间"

#: ../source/tutorial/modules.rst:7 0b8d2f1619c54dfc9c257232b21dca74
msgid ""
"An Idris program consists of a collection of modules. Each module "
"includes an optional ``module`` declaration giving the name of the "
"module, a list of ``import`` statements giving the other modules which "
"are to be imported, and a collection of declarations and definitions of "
"types, interfaces and functions. For example, the listing below gives a "
"module which defines a binary tree type ``BTree`` (in a file "
"``BTree.idr``):"
msgstr ""
"一个 Idris 程序由一个模块的集合组成。每个模块包括一个可选的 ``module`` "
"声明，用来给出模块的名称，一个 ``import`` 声明列表，给出要导入的其他模块，以"
"及一个类型、接口和函数的声明和定义的集合。例如，"
"下面的列表给出了一个定义二叉树类型的模块 ``BTree`` （在文件 ``BTree.idr`` "
"中）："

#: ../source/tutorial/modules.rst:39 dc86d2841b444dfc844b69eb3f959bdf
msgid ""
"The modifiers ``export`` and ``public export`` say which names are "
"visible from other namespaces. These are explained further below."
msgstr "修饰词 ``export`` 和 ``public export`` "
"表示哪些名称对其他命名空间可见。这些将在下面进一步解释。"

#: ../source/tutorial/modules.rst:42 f6eec1d153084496b1e48cc7751e1389
msgid ""
"Then, this gives a main program (in a file ``bmain.idr``) which uses the "
"``BTree`` module to sort a list:"
msgstr "然后，这就给出了一个主程序（在文件 ``bmain.idr`` 中），它使用 ``BTree`` "
"模块对一个列表进行排序："

#: ../source/tutorial/modules.rst:55 81d8eebfdc9349a48b419d0e7924cde9
msgid ""
"The same names can be defined in multiple modules: names are *qualified* "
"with the name of the module. The names defined in the ``BTree`` module "
"are, in full:"
msgstr "相同的名字可以被定义在多个模块中：名字可以用模块的名字来 *限定* 。在 "
"``BTree`` 模块中定义的名字，全限定名如下："

#: ../source/tutorial/modules.rst:58 c12b8220e42b4ddc8b8a2f4c3ca08fa8
msgid "``BTree.BTree``"
msgstr "``BTree.BTree``"

#: ../source/tutorial/modules.rst:59 bc06b8a3ead842f492f3774d26f1331e
msgid "``BTree.Leaf``"
msgstr "``BTree.Leaf``"

#: ../source/tutorial/modules.rst:60 6834d661193a4d908128f388930ee2cd
msgid "``BTree.Node``"
msgstr "``BTree.Node``"

#: ../source/tutorial/modules.rst:61 0d59c69b40c543ec887dfc2cf3ea7c33
msgid "``BTree.insert``"
msgstr "``BTree.insert``"

#: ../source/tutorial/modules.rst:62 17d950159eba4745bf80b266c008148e
msgid "``BTree.toList``"
msgstr "``BTree.toList``"

#: ../source/tutorial/modules.rst:63 681fbf364e3847dbb4c3cf032b093c6b
msgid "``BTree.toTree``"
msgstr "``BTree.toTree``"

#: ../source/tutorial/modules.rst:65 e76fbc50f30d44ecaea950ed9e0785cf
msgid ""
"If names are otherwise unambiguous, there is no need to give the fully "
"qualified name. Names can be disambiguated either by giving an explicit "
"qualification, using the ``with`` keyword, or according to their type."
msgstr "如果名字没有歧义，就没有必要给出完全限定的名字。名称也可以通过使用 ``with`` "
"关键字给出一个明确的限定，或者根据它们的类型来消除歧义。"

#: ../source/tutorial/modules.rst:69 1e0a0b8fcb414a1285d08d5dcfb8d4fb
msgid "The ``with`` keyword in expressions comes in two variants:"
msgstr "``with`` 表达式中的关键字有两种变体："

#: ../source/tutorial/modules.rst:71 520b1fcffa1b41648c535f825cde0a63
msgid "``with BTree.insert (insert x empty)`` for one name"
msgstr "``with BTree.insert (insert x empty)`` 用于单个名称"

#: ../source/tutorial/modules.rst:72 0c95cc8acb0f4ab194e977647f231b81
msgid "``with [BTree.insert, BTree.empty] (insert x empty)`` for multiple names"
msgstr "``with [BTree.insert, BTree.empty] (insert x empty)`` 用于多个名称"

#: ../source/tutorial/modules.rst:74 725fdc5bfdb74a3294e594d8d0e79485
msgid ""
"This is particularly useful with ``do`` notation, where it can often "
"improve error messages: ``with MyModule.(>>=) do ...``"
msgstr "这对于 ``do`` 记法特别有用，它通常可以改善错误消息： ``with MyModule.(>>=) "
"do ...``"

#: ../source/tutorial/modules.rst:77 ab9b403e9fc2431eae76f20f26ce67c3
msgid ""
"If a file contains a module declaration ``module Foo.Bar.MyModule``, its "
"path relative to the ``sourcedir`` specified in the ``.ipkg`` project "
"file (defaults to ``.``) must be ``./Foo/Bar/MyModule.idr``. If you are "
"not using an ``.ipkg`` project file, the path must be relative to the "
"directory you are running Idris from. Similarly, an ``import`` statement "
"also refers to such a relative filepath stripped of its file extension, "
"using dots to separate directories. As in the example above, all modules "
"names and directories must be capitalised identifiers. If a file does not"
" contain a module declaration, it is considered to be a module whose "
"identifier is ``Main``."
msgstr "如果一个文件包含模块声明 ``module Foo.Bar.MyModule``，那么它在 ``.ipkg`` 项目文件中 `sourcedir`（默认为 ``.``）下的相对路径必须为 ``./Foo/Bar/MyModule.idr``。如果你没有使用 ``.ipkg`` 项目文件，则路径必须相对于你运行 Idris 的目录。同理，``import`` 语句也指向去掉扩展名后的相对文件路径，目录之间用点分隔。如上例，所有模块名和目录都必须是首字母大写的标识符。如果文件没有模块声明，则被视为模块 ``Main``。"

#: ../source/tutorial/modules.rst:88 1f566b6867854b5e8db827fdf45c2b18
msgid "Export Modifiers"
msgstr "导出修饰符"

#: ../source/tutorial/modules.rst:90 dc028ef550ce49eda9ce1c462c29a209
msgid ""
"Idris allows for fine-grained control over the visibility of a "
"namespace's contents. By default, all names defined in a namespace are "
"kept private.  This aids in specification of a minimal interface and for "
"internal details to be left hidden. Idris allows for functions, types, "
"and interfaces to be marked as: ``private``, ``export``, or ``public "
"export``. Their general meaning is as follows:"
msgstr ""
"Idris 允许对命名空间内容的可见性进行精细的控制。默认情况下，所有定义在名字空"
"间的名字都是私有的。 这有助于规范一个最小的接口和隐藏内部细节。Idris "
"允许函数、类型和接口被标记为 ``private``, ``export`` 或 ``public export`` "
"。它们的一般含义如下："

#: ../source/tutorial/modules.rst:97 99dcefd65a134a81b86b4ea30d923c63
msgid "``private`` meaning that it is not exported at all. This is the default."
msgstr "``private`` 意味着它不会被导出。这是默认设置。"

#: ../source/tutorial/modules.rst:99 6e1fa857a5b84a7ba45834cf0ead997b
msgid "``export`` meaning that its top level type is exported."
msgstr "``export`` 意味着顶层类型已被导出。"

#: ../source/tutorial/modules.rst:101 23ba7b22cfbe43a8ae049fd3c1dfbb6c
msgid "``public export`` meaning that the entire definition is exported."
msgstr "``public export`` 意味着整个定义被导出。"

#: ../source/tutorial/modules.rst:103 c122bbba5fc748399eba7be13e603392
msgid ""
"A further restriction in modifying the visibility is that definitions "
"must not refer to anything within a lower level of visibility. For "
"example, ``public export`` definitions cannot use ``private`` or "
"``export`` names, and ``export`` types cannot use ``private`` names. This"
" is to prevent private names leaking into a module's interface."
msgstr ""
"修改可见性的另一个限制是，定义不能引用更低层次的可见性中的任何东西。例如， ``"
"public export`` 定义不能使用 ``private`` 或 ``export`` 名称，而 ``export`` "
"类型不能使用 ``private`` 名称。这是为了防止私有名称泄露到模块的接口中。"

#: ../source/tutorial/modules.rst:110 ad18d59734df4097a9c36f3df7de7fe5
msgid "Meaning for Functions"
msgstr "用于函数时的含义"

#: ../source/tutorial/modules.rst:112 e4e3d741f9c44769880929ae15d55e09
msgid "``export`` the type is exported"
msgstr "``export`` 类型被导出"

#: ../source/tutorial/modules.rst:114 f923c145772440bba77aed2d4828460c
msgid ""
"``public export`` the type and definition are exported, and the "
"definition can be used after it is imported. In other words, the "
"definition itself is considered part of the module's interface. The long "
"name ``public export`` is intended to make you think twice about doing "
"this."
msgstr ""
"``public export`` 类型和定义被导出，定义被导入后可以使用。换句话说，定义本身"
"被认为是模块接口的一部分。 ``public export`` "
"这个长名字是为了让你在做这件事时三思而行。"

#: ../source/tutorial/modules.rst:122 ea8d42af9f3144518bedd8d49e69b356
msgid ""
"Type synonyms in Idris are created by writing a function. When setting "
"the visibility for a module, it is usually a good idea to ``public "
"export`` all type synonyms if they are to be used outside the module. "
"Otherwise, Idris won't know what the synonym is a synonym for."
msgstr ""
"Idris 中的类型同义词是通过编写函数创建的。设置模块的可见性时，如果要在模块外"
"使用所有类型的同义词，最好将它们设置为 ``public export`` 。否则，Idris "
"将不知道该同义词是谁的同义词。"

#: ../source/tutorial/modules.rst:128 5a12cdce12bf41c492a194bfad988ec3
msgid ""
"Since ``public export`` means that a function's definition is exported, "
"this effectively makes the function definition part of the module's API. "
"Therefore, it's generally a good idea to avoid using ``public export`` "
"for functions unless you really mean to export the full definition."
msgstr ""
"由于 ``public export`` 意味着一个函数的定义被导出，"
"这实际上使函数定义成为模块 API "
"的一部分。因此，一般来说，除非你真的想导出完整的定义，否则最好不要对函数使用 "
"``public export`` 。"

#: ../source/tutorial/modules.rst:134 5d88d5227c304ddaa7e59e48ce7929de
msgid ""
"*For beginners*: If the function needs to be accessed only at runtime, "
"use ``export``. However, if it's also meant to be used at *compile* time "
"(e.g. to prove a theorem), use ``public export``. For example, consider "
"the function ``plus : Nat -> Nat -> Nat`` discussed previously, and the "
"following theorem: ``thm : plus Z m = m``. In order to prove it, the type"
" checker needs to reduce ``plus Z m`` to ``m`` (and hence obtain ``thm : "
"m = m``). To achieve this, it will need access to the *definition* of "
"``plus``, which includes the equation ``plus Z m = m``. Therefore, in "
"this case, ``plus`` has to be marked as ``public export``."
msgstr ""
"*对于初学者* 。如果函数只需要在运行时访问，使用 ``export`` 。但是，"
"如果它也要在 *编译时使用* （例如，证明一个定理），则使用 ``public export`` "
"。例如，考虑前面讨论的函数 ``plus : Nat -> Nat -> Nat`` ，以及下面的定理。 ``"
"thm : plus Z m = m`` 。为了证明它，类型检查器需要将 ``plus Z m`` 还原为 ``m``"
" （从而得到 ``thm : m = m`` ）。* 为了实现这一点，它需要访问*的定义 ``plus`` "
"，其中包括方程式 ``plus Z m = m`` 。因此，在这种情况下， ``plus`` "
"必须被标记为 ``public export`` 。"

#: ../source/tutorial/modules.rst:147 01fbdad7222c4305831855d8ea638390
msgid "Meaning for Data Types"
msgstr "数据类型的含义"

#: ../source/tutorial/modules.rst:149 f3530e33f05647a6aa4968d0f7c9c498
msgid "For data types, the meanings are:"
msgstr "对于数据类型，其含义是："

#: ../source/tutorial/modules.rst:151 bb7114b7bc764eaaac2fa8a8805f09ba
msgid "``export`` the type constructor is exported"
msgstr "``export`` 类型构造器被导出"

#: ../source/tutorial/modules.rst:153 5650eee7cd2c4fcda1627aa28a21e27b
msgid "``public export`` the type constructor and data constructors are exported"
msgstr "``public export`` 类型构造器和数据构造器会被导出"

#: ../source/tutorial/modules.rst:157 ddd0190ef01f4d74ad6f065ff4a98f32
msgid "Meaning for Interfaces"
msgstr "接口上的含义"

#: ../source/tutorial/modules.rst:159 225cb96390074ca3a9f90dc18b5e4975
msgid "For interfaces, the meanings are:"
msgstr "对于接口，其含义是："

#: ../source/tutorial/modules.rst:161 f4cd85a062044a9ea8a773252a3ced74
msgid "``export`` the interface name is exported"
msgstr "``export`` 接口名称被导出"

#: ../source/tutorial/modules.rst:163 ebc3ddcac7304e4fbd4a4b63d36517a1
msgid ""
"``public export`` the interface name, method names and default "
"definitions are exported"
msgstr "``public export`` 接口名称、方法名称和默认定义被导出"

#: ../source/tutorial/modules.rst:167 550bee9ae05b473aa76ee3a5d6bff0b0
msgid "Meaning for fixity declarations"
msgstr "优先级声明的含义"

#: ../source/tutorial/modules.rst:169 693af72dfb5045999be97e5de37900b6
msgid ""
"The modifiers differ slightly when applied to fixities. Un-labelled "
"fixities are exported rather than be private. There is no difference "
"between `public export` and `export`. In summary:"
msgstr "修饰符应用于运算符优先级声明时略有不同。未加修饰的优先级声明会被导出，而不是私有。`public export` 和 `export` 没有区别。总结如下："

#: ../source/tutorial/modules.rst:173 6b869c6c4d5441a4a318e6506dab459e
msgid "``private`` means the fixity declaration is only visible within the file."
msgstr "``private`` 表示优先级声明仅在当前文件内可见。"

#: ../source/tutorial/modules.rst:175 4cc90dcccd6542d8b8abc756fa7ba47e
msgid ""
"``public export`` and ``export`` are the same and the fixity is exported. "
"The access modifier could also be eluded for the same effect."
msgstr "``public export`` 和 ``export`` 等价，都会导出优先级声明。不加修饰符也有同样效果。"

#: ../source/tutorial/modules.rst:179 ef74db8eecaa49779ab6371f70a246f2
msgid "Propagating Inner Module API's"
msgstr "传播内部模块的 API"

#: ../source/tutorial/modules.rst:181 4ab0aa8b88c64fd59cee273c90a36bae
msgid ""
"Additionally, a module can re-export a module it has imported, by using "
"the ``public`` modifier on an ``import``. For example:"
msgstr "此外，一个模块可以重新输出它所导入的模块，方法是在 ``public`` 修改器上使用 "
"``import`` 。例如："

#: ../source/tutorial/modules.rst:191 87d5066c73dc4c4a90f88f1f58ef1a78
msgid ""
"The module ``A`` will export the name ``a``, as well as any public or "
"abstract names in module ``C``, but will not re-export anything from "
"module ``B``."
msgstr "模块 ``A`` 将导出名称 ``a`` 以及模块 ``C`` 中的任何公共或抽象名称，"
"但不会从模块 ``B`` 重新导出任何东西。"

#: ../source/tutorial/modules.rst:196 4a44e17c18434a9498ea2a8fb6f303dd
msgid "Renaming imports"
msgstr "重命名导入"

#: ../source/tutorial/modules.rst:198 9657d0323111423f82fc8a2b7059dc3b
msgid ""
"Sometimes it is convenient to be able to access the names in another "
"module via a different namespace (typically, a shorter one). For this, "
"you can use `import...as`. For example:"
msgstr "有时，能够通过不同的命名空间（通常是较短的命名空间）访问另一个模块中的名称是"
"很方便的。为此，你可以使用 `import...as` 。例如："

#: ../source/tutorial/modules.rst:208 99d1d8eb210346bf8469081989b3c134
msgid ""
"This module ``A`` has access to the exported names from module "
"``Data.List``, but can also explicitly access them via the module name "
"``L``. ``import...as`` can also be combined with ``import public`` to "
"create a module which exports a larger API from other sub-modules:"
msgstr ""
"这个模块 ``A`` 可以访问从模块 ``Data.List`` 导出的名称，但也可以通过模块名称 "
"``L`` 明确地访问它们。 ``import...as`` 也可以与 ``import public`` "
"结合起来，创建一个模块，从其他子模块导出一个更大的API："

#: ../source/tutorial/modules.rst:220 ae6744a19e734cb8bd5cc4272925d390
msgid ""
"Here, any module which imports ``Books`` will have access to the exported"
" interfaces of ``Books.Hardback`` and ``Books.Comic`` both under the "
"namespace ``Books``."
msgstr ""
"在这里，任何导入 ``Books`` 的模块都可以访问 ``Books.Hardback`` 和 ``Books."
"Comic`` 的导出接口，两者都在命名空间 ``Books`` 。"

#: ../source/tutorial/modules.rst:225 eefc0284e10d42e185b4ecfd5289f8f3
msgid "Explicit Namespaces"
msgstr "显式命名空间"

#: ../source/tutorial/modules.rst:227 9d224113f6a54da88def2c84fa60a1f6
msgid ""
"Defining a module also defines a namespace implicitly. However, "
"namespaces can also be given *explicitly*. This is most useful if you "
"wish to overload names within the same module:"
msgstr "定义一个模块也隐含地定义了一个命名空间。然而，命名空间也可以被 *明确* 地赋予 "
"。如果你想在同一个模块中重载名字，这会非常有用："

#: ../source/tutorial/modules.rst:245 51e327a4e7204b8f945c04959f98448c
msgid ""
"This (admittedly contrived) module defines two functions with fully "
"qualified names ``Foo.X.test`` and ``Foo.Y.test``, which can be "
"disambiguated by their types:"
msgstr "这个模块（公认是设计好的）定义了两个函数，其全称是 ``Foo.X.test`` 和 ``Foo.Y."
"test`` ，可以通过其类型来区分："

#: ../source/tutorial/modules.rst:256 f91bbf28f60a4c2cbb0cc0d75a92db19
msgid ""
"The export rules, ``public export`` and ``export``, are *per namespace*, "
"not *per file*, so the two ``test`` definitions above need the ``export``"
" flag to be visible outside their own namespaces."
msgstr ""
"导出规则 ``public export`` 和 ``export`` ，是 *按命名空间* ，而不是 *按文件* "
"，所以上面的两个 ``test`` 定义需要 ``export`` "
"标志才能在它们自己的命名空间之外可见。"

#: ../source/tutorial/modules.rst:261 021f89a18886411f83e0486473bd2090
msgid "Explicit namespaces inside functions"
msgstr "函数内的显式命名空间"

#: ../source/tutorial/modules.rst:263 aae9681f621040f1aeda27f5595dd488
msgid ""
"Explicit namespaces can be defined inside ``where``-blocks of functions. "
"Unlike other definitions (e.g. ``data`` or ``record``), such namespace "
"definitions are understood as belonging to the scope of the function "
"definition itself."
msgstr "可以在函数的 ``where`` 块中显式定义命名空间。与其他定义（如 ``data`` 或 ``record``）不同，这类命名空间定义被视为属于该函数定义自身的作用域。"

#: ../source/tutorial/modules.rst:268 b5edccbf30f344a19f6447d513b8fe69
msgid "For example, the following code should typecheck."
msgstr "例如，下面的代码可以通过类型检查。"

#: ../source/tutorial/modules.rst:282 80ff9a36e29744a8bd459d7e21abd85f
msgid ""
"Notice that if a function that contains namespace definition has "
"parameters, then definitions inside this namespace will have these "
"parameters too. This is done because such definitions have access to "
"values of the parameters."
msgstr "注意，如果一个包含命名空间定义的函数有参数，则该命名空间内的定义也会拥有这些参数。这是因为这些定义可以访问这些参数的值。"

#: ../source/tutorial/modules.rst:286 e7e5a89dde5347989820b0233042ce5a
msgid ""
"These parameters must be passed explicitly when accessing namespaced "
"definitions from outside the function where they are declared, and must "
"not be passed when accessed from the inside. This behaviour is similar to"
" parameterised blocks described below. Look at the following example."
msgstr "当从函数外部访问带命名空间的定义时，必须显式传递这些参数；而在函数内部访问时则不需要传递。这一行为类似于下文描述的参数化块。请看如下示例。"

#: ../source/tutorial/modules.rst:305 23f6b262deaa4aa8b30d99871c671f48
msgid "Parameterised blocks - `parameters`-blocks"
msgstr "参数化块 - `parameters` 块"

#: ../source/tutorial/modules.rst:307 9867148cc0bf4697be3d70f65be85a3d
msgid ""
"Groups of functions can be parameterised over a number of arguments using"
" a ``parameters`` declaration, for example:"
msgstr "例如，可以使用 ``parameters`` 声明，在一些参数上对函数组进行参数化："

#: ../source/tutorial/modules.rst:316 21ee397fba9d409ba440b22fa57ede03
msgid ""
"The effect of a ``parameters`` block is to add the declared parameters to"
" every function, type and data constructor within the block. "
"Specifically, adding the parameters to the front of the argument list. "
"Outside the block, the parameters must be given explicitly. The "
"``addAll`` function, when called from the REPL, will thus have the "
"following type signature."
msgstr ""
"``parameters`` 块的作用是将声明的参数添加到该块内的每个函数、类型和数据构造器"
"中。具体来说，就是将参数添加到参数列表的前面。在块之外，必须明确地给出参数。 "
"``addAll`` 函数，当从 REPL 中调用时，将有以下类型签名。"

#: ../source/tutorial/modules.rst:328 3fb9e1f7ba404ac8bc9bfa22d15c8bf0
msgid "and the following definition."
msgstr "和以下定义。"

#: ../source/tutorial/modules.rst:335 c4fc3cd96623494893db56513332d047
msgid ""
"Parameters blocks can be nested, and can also include data declarations, "
"in which case the parameters are added explicitly to all type and data "
"constructors. They may also be dependent types with implicit arguments:"
msgstr "参数块可以是嵌套的，也可以包括数据声明，在这种情况下，参数被明确地添加到所有"
"类型和数据构造器中。它们也可以是具有隐含参数的依值类型："

#: ../source/tutorial/modules.rst:348 0ff1be00e9cf40e1a64a4665738cf6d7
msgid ""
"To use ``Vects`` or ``append`` outside the block, we must also give the "
"``xs`` and ``y`` arguments. Here, we can use placeholders for the values "
"which can be inferred by the type checker:"
msgstr ""
"要在块外使用 ``Vects`` 或 ``append`` ，我们还必须给出 ``xs`` 和 ``y`` "
"的参数。在这里，我们可以使用占位符来表示可以由类型检查器推断出来的值："

#: ../source/tutorial/modules.rst:357 571dd666020343ceb7f05423d3da8dae
msgid ""
"You can specify what quantity and if the parameters are implicits using "
"the same syntax as record parameters."
msgstr "你可以用与记录参数相同的语法，指定参数的数量以及是否为隐式参数。"
