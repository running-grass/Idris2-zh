# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020-2023, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 09:52+0800\n"
"PO-Revision-Date: 2022-09-03 13:48+0000\n"
"Last-Translator: grass <hi@grass.show>\n"
"Language-Team: Chinese (Simplified) <>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../source/tutorial/miscellany.rst:5 c18d81393c43423388d88d776cd7f868
msgid "Miscellany"
msgstr "杂项"

#: ../source/tutorial/miscellany.rst:7 6f06fbb3cc414cf1b2842ab072b6b851
msgid "In this section we discuss a variety of additional features:"
msgstr "在本节中，我们将讨论各种附加功能："

#: ../source/tutorial/miscellany.rst:9 d929a7e8d03e45249032bcf8bb399176
msgid "auto, implicit, and default arguments;"
msgstr "自动、隐式和默认参数；"

#: ../source/tutorial/miscellany.rst:10 1afc9617644f40679fb4bc4309d38d2a
msgid "literate programming; and"
msgstr "文学编程；和"

#: ../source/tutorial/miscellany.rst:11 280967e0139e45f6bd4cf2801f27c131
msgid "the universe hierarchy."
msgstr "全域层级。"

#: ../source/tutorial/miscellany.rst:14 b0d239f476dc4be99cc67746733e2d3f
msgid "Implicit arguments"
msgstr "隐式参数"

#: ../source/tutorial/miscellany.rst:16 e75636c21e5b4fc6b8ca0a0be515494b
msgid ""
"We have already seen implicit arguments, which allows arguments to be "
"omitted when they can be inferred by the type checker [#IdrisType]_, e.g."
msgstr "我们已经看到了隐式参数，它允许在类型检查器 [#IdrisType]_ "
"在可以推断出参数时省略参数，例如。"

#: ../source/tutorial/miscellany.rst:26 af5850e8824f4fc0ab2ea159c60b0f39
msgid "Auto implicit arguments"
msgstr "自动隐式参数"

#: ../source/tutorial/miscellany.rst:28 c88e64ec6cb64c7193b41e5f5b569f0a
msgid ""
"In other situations, it may be possible to infer arguments not by type "
"checking but by searching the context for an appropriate value, or "
"constructing a proof. For example, the following definition of ``head`` "
"which requires a proof that the list is non-empty:"
msgstr ""
"在其他情况下，可能不是通过类型检查而是通过在上下文中搜索适当的值或构造证明来"
"推断参数。例如，下面 ``head`` 的定义需要证明列表是非空的："

#: ../source/tutorial/miscellany.rst:42 f92865697d554b729523d48022f63b74
msgid ""
"If the list is statically known to be non-empty, either because its value"
" is known or because a proof already exists in the context, the proof can"
" be constructed automatically. Auto implicit arguments allow this to "
"happen silently. We define ``head`` as follows:"
msgstr ""
"如果列表静态已知为非空，或者因为它的值是已知的，或者因为上下文中已经存在证明"
"，则可以自动构造证明。自动隐式参数允许这种情况静默发生。我们定义 ``head`` "
"如下："

#: ../source/tutorial/miscellany.rst:52 f9778176b63743548a1773386b1901df
msgid ""
"The ``auto`` annotation on the implicit argument means that Idris will "
"attempt to fill in the implicit argument by searching for a value of the "
"appropriate type. In fact, internally, this is exactly how interface "
"resolution works. It will try the following, in order:"
msgstr ""
"隐式参数上的 ``auto`` 注解意味着 Idris 将尝试通过搜索适当类型的值来填充隐式参"
"数。事实上，在内部，这正是接口解析的工作方式。它将按顺序尝试以下操作："

#: ../source/tutorial/miscellany.rst:57 f39fb14fd0be4e81bf69920bcceb657e
msgid ""
"Local variables, i.e. names bound in pattern matches or ``let`` bindings,"
" with exactly the right type."
msgstr "局部变量，即模式匹配或 ``let`` 绑定中的名称，具有完全正确的类型。"

#: ../source/tutorial/miscellany.rst:59 a5cbeb197c76493a83499b208d5c8f05
msgid ""
"The constructors of the required type. If they have arguments, it will "
"search recursively up to a maximum depth of 100."
msgstr "所需类型的构造函数。如果它们有参数，它将递归搜索的最大深度为 100。"

#: ../source/tutorial/miscellany.rst:61 707eb08f4ecc4e11b29a607102de30ee
msgid ""
"Local variables with function types, searching recursively for the "
"arguments."
msgstr "具有函数类型的局部变量，递归搜索参数。"

#: ../source/tutorial/miscellany.rst:63 6b75119da9a445159b4e79c544830475
#, python-format
msgid ""
"Any function with the appropriate return type which is marked with the "
"``%hint`` annotation."
msgstr "任何具有适当返回类型且标有 ``%hint`` 注解的函数。"

#: ../source/tutorial/miscellany.rst:66 a187e776098a4098a22e2cefbd271f5f
msgid ""
"In the case that a proof is not found, it can be provided explicitly as "
"normal:"
msgstr "在没有找到证明的情况下，可以像往常一样明确提供："

#: ../source/tutorial/miscellany.rst:73 9b10ac3bef2f43b6a1425b87bad97c77
msgid "Default implicit arguments"
msgstr "默认隐式参数"

#: ../source/tutorial/miscellany.rst:75 58c1984a6db84b27822458c76084ab84
msgid ""
"Besides having Idris automatically find a value of a given type, "
"sometimes we want to have an implicit argument with a specific default "
"value. In Idris, we can do this using the ``default`` annotation. While "
"this is primarily intended to assist in automatically constructing a "
"proof where auto fails, or finds an unhelpful value, it might be easier "
"to first consider a simpler case, not involving proofs."
msgstr ""
"除了让 Idris "
"自动查找给定类型的值之外，有时我们还希望有一个具有特定默认值的隐式参数。在 "
"Idris 中，我们可以使用 ``default`` 注解来做到这一点。"
"虽然这主要是为了帮助自动构建 auto "
"失败或发现无用值的证明，但首先考虑不涉及证明的更简单的情况可能更容易。"

#: ../source/tutorial/miscellany.rst:81 525cc2f9adfd4ae6a9e18745e212e6ba
msgid ""
"If we want to compute the n'th fibonacci number (and defining the 0th "
"fibonacci number as 0), we could write:"
msgstr "如果我们想计算第 n 个斐波那契数（并将第 0 个斐波那契数定义为 "
"0），我们可以这样写："

#: ../source/tutorial/miscellany.rst:90 0e947076fddd4adfbbd70e795094e7a7
msgid ""
"After this definition, ``fibonacci 5`` is equivalent to ``fibonacci "
"{lag=0} {lead=1} 5``, and will return the 5th fibonacci number. Note that"
" while this works, this is not the intended use of the ``default`` "
"annotation. It is included here for illustrative purposes only. Usually, "
"``default`` is used to provide things like a custom proof search script."
msgstr ""
"在这个定义之后， ``fibonacci 5`` 等价于 ``fibonacci {lag=0} {lead=1} 5`` ，"
"并且会返回第 5 个斐波那契数。请注意，虽然这有效，但这不是 ``default`` "
"注解的预期用途。此处仅用于说明目的。通常， ``default`` "
"用于提供自定义证明搜索脚本之类的东西。"

#: ../source/tutorial/miscellany.rst:96 f908f579c1ae4b90b7b453be33103273
msgid "Literate programming"
msgstr "文学编程"

#: ../source/tutorial/miscellany.rst:98 96b751e61d024099b182359aa78f87f7
msgid ""
"Like Haskell, Idris supports *literate* programming. If a file has an "
"extension of ``.lidr`` then it is assumed to be a literate file. In "
"literate programs, everything is assumed to be a comment unless the line "
"begins with a greater than sign ``>``, for example:"
msgstr ""
"与 Haskell 一样，Idris 支持 *文学* 编程。如果一个文件的扩展名为 .lidr ，"
"那么它被认为是一个 文学(literate) "
"文件。在文学编程中，所有内容都被假定为注释，除非该行以大于号 ``>`` "
"开头，例如："

#: ../source/tutorial/miscellany.rst:112 25ae7462fe744dd69c94117fb2402243
msgid ""
"An additional restriction is that there must be a blank line between a "
"program line (beginning with ``>``) and a comment line (beginning with "
"any other character)."
msgstr "另一个限制是程序行（以 ``>`` "
"开头）和注释行（以任何其他字符开头）之间必须有一个空行。"

#: ../source/tutorial/miscellany.rst:117 1169c95edde1457d9e051d07cff5b980
msgid "Cumulativity"
msgstr "累积性"

#: ../source/tutorial/miscellany.rst:121 97f807db7e774a22a7b820e0ad7256c9
msgid "NOT YET IN IDRIS 2"
msgstr "尚未在 IDRIS 2 中"

#: ../source/tutorial/miscellany.rst:123 1fc731696bdc427a9f78dbb28941919f
msgid ""
"Since values can appear in types and *vice versa*, it is natural that "
"types themselves have types. For example:"
msgstr "由于值可以出现在类型中，然后 *反之亦然* "
"，因此类型本身具有类型是很自然的。例如："

#: ../source/tutorial/miscellany.rst:133 9fcfdbc8a4234c15904046d95756a815
msgid "But what about the type of ``Type``? If we ask Idris it reports:"
msgstr "但是 ``Type`` 的类型呢？如果我们问 Idris ，它会报告："

#: ../source/tutorial/miscellany.rst:140 18540766a7a346079289c78cc178ce8e
msgid ""
"If ``Type`` were its own type, it would lead to an inconsistency due to "
"`Girard’s paradox "
"<https://www.cs.cmu.edu/afs/cs.cmu.edu/user/kw/www/scans/girard72thesis.pdf>`_,"
" so internally there is a *hierarchy* of types (or *universes*):"
msgstr ""
"如果 ``Type`` 是它自己的类型，那么它会因为 `Girard 悖论 <https://www.cs.cmu."
"edu/afs/cs.cmu.edu/user/kw/www/scans/girard72thesis.pdf>`_ 而导致不一致性，"
"所以内部有一个 *层级* 类型（或 *全域* ）："

#: ../source/tutorial/miscellany.rst:148 0f01802416a444b3b2aa7738458880ec
msgid ""
"Universes are *cumulative*, that is, if ``x : Type n`` we can also have "
"that ``x : Type m``, as long as ``n < m``. The typechecker generates such"
" universe constraints and reports an error if any inconsistencies are "
"found. Ordinarily, a programmer does not need to worry about this, but it"
" does prevent (contrived) programs such as the following:"
msgstr ""
"全域是 *累积的* ，也就是说，如果 ``x : Type n`` 我们也可以拥有 ``x : Type m``"
" ，只要 ``n < m`` 。如果发现任何不一致，类型检查器会生成这样的全域约束并报告"
"错误。通常，程序员不需要担心这一点，但它确实会防止（构造出）以下程序："

#: ../source/tutorial/miscellany.rst:162 5cc232ac92d34b6db5f771ece09929a7
msgid ""
"The application of ``myid`` to itself leads to a cycle in the universe "
"hierarchy — ``myid``\\ ’s first argument is a ``Type``, which cannot be "
"at a lower level than required if it is applied to itself."
msgstr ""
"``myid`` 对自身的应用会导致 Universe 层次结构中的循环 - ``myid`` "
"的第一个参数是 ``Type`` ，如果应用它，那么其级别不能低于所要求的级别。"

#: ../source/tutorial/miscellany.rst:166 388ba373ed1846578ece70f41b5853a1
msgid "https://github.com/david-christiansen/idris-type-providers"
msgstr "https://github.com/david-christiansen/idris-type-providers"
