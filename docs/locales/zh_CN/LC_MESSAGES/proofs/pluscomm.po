# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020-2023, The Idris Community
# This file is distributed under the same license as the Idris2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: Idris2 0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 09:52+0800\n"
"PO-Revision-Date: 2022-09-03 13:48+0000\n"
"Last-Translator: grass <hi@grass.show>\n"
"Language-Team: Chinese (Simplified) <>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../source/proofs/pluscomm.rst:3 dde617d274e842388244ed4978e7c51b
msgid "Running example: Addition of Natural Numbers"
msgstr "运行示例：自然数加法（Addition of Natural Numbers）"

#: ../source/proofs/pluscomm.rst:5 375a551d741d490492e2cd5688070450
msgid "Throughout this tutorial, we will be working with the following function, defined in the Idris prelude, which defines addition on natural numbers:"
msgstr "在本教程中，我们将使用 Idris prelude（前置库）中定义的如下函数，该函数定义了自然数的加法："

#: ../source/proofs/pluscomm.rst:15 af9ca1a5f6ff4a6992f89a7052f78b81
msgid "It is defined by the above equations, meaning that we have for free the properties that adding ``m`` to zero always results in ``m``, and that adding ``m`` to any non-zero number ``S k`` always results in ``S (plus k m)``. We can see this by evaluation at the Idris REPL (i.e. the prompt, the read-eval-print loop):"
msgstr "它由上述等式定义，这意味着我们天然拥有如下性质：将 ``m`` 加到零上总是得到 ``m``，而将 ``m`` 加到任意非零数 ``S k`` 上总是得到 ``S (plus k m)``。我们可以在 Idris REPL（即命令行交互环境）中通过求值看到这一点："

#: ../source/proofs/pluscomm.rst:29 5a3042a68d0048bf8eaf0c001c7e535b
msgid "Note that unlike many other language REPLs, the Idris REPL performs evaluation on *open* terms, meaning that it can reduce terms which appear inside lambda bindings, like those above. Therefore, we can introduce unknowns ``k`` and ``m`` as lambda bindings and see how ``plus`` reduces."
msgstr "注意，与许多其他语言的 REPL 不同，Idris REPL 可以对*开放*项进行归约，这意味着它可以化简出现在 lambda 绑定中的项，如上例所示。因此，我们可以将未知数 ``k`` 和 ``m`` 作为 lambda 绑定引入，并观察 ``plus`` 的归约过程。"

#: ../source/proofs/pluscomm.rst:35 0be8a900f5264177adc5cf12b0edd1aa
msgid "The ``plus`` function has a number of other useful properties, for example:"
msgstr "``plus`` 函数还有许多其他有用的性质，例如："

#: ../source/proofs/pluscomm.rst:38 bba3d044f5424796885226b2bb5fc796
msgid "It is *commutative*, that is for all ``Nat`` inputs ``n`` and ``m``, we know that ``plus n m = plus m n``."
msgstr "它是*交换的*，即对于所有 ``Nat`` 类型的输入 ``n`` 和 ``m``，都有 ``plus n m = plus m n``。"

#: ../source/proofs/pluscomm.rst:41 9c3583844c6b4a7d866f6d20d2d7e22d
msgid "It is *associative*, that is for all ``Nat`` inputs ``n``, ``m`` and ``p``, we know that ``plus n (plus m p) = plus (plus m n) p``."
msgstr "它是*结合的*，即对于所有 ``Nat`` 类型的输入 ``n``、``m`` 和 ``p``，都有 ``plus n (plus m p) = plus (plus m n) p``。"

#: ../source/proofs/pluscomm.rst:44 5e813247d9014118b3499dbd77ddf732
msgid "We can use these properties in an Idris program, but in order to do so we must *prove* them."
msgstr "我们可以在 Idris 程序中使用这些性质，但为此我们必须*证明*它们。"

#: ../source/proofs/pluscomm.rst:48 e83c4fc02b1841c98a45432e90d30a1e
msgid "Equality Proofs"
msgstr "等式证明（Equality Proofs）"

#: ../source/proofs/pluscomm.rst:50 da4b6589beb54da8a29a887fd6f8f04f
msgid "Idris defines a propositional equality type as follows:"
msgstr "Idris 定义了如下命题等式类型："

#: ../source/proofs/pluscomm.rst:57 45a79414c9b54dc6a0d378b2e43a5eba
msgid "As syntactic sugar, ``Equal x y`` can be written as ``x = y``."
msgstr "作为语法糖，``Equal x y`` 可以写作 ``x = y``。"

#: ../source/proofs/pluscomm.rst:59 2ade4ba818f24acbb5038c948bbfbc55
msgid "It is *propositional* equality, where the type states that any two values in different types ``a`` and ``b`` may be proposed to be equal. There is only one way to *prove* equality, however, which is by reflexivity (``Refl``)."
msgstr "这是一种*命题*等式，其类型声明任意两个不同类型 ``a`` 和 ``b`` 的值都可以被提议为相等。然而，只有一种方式可以*证明*等式，即自反性（``Refl``）。"

#: ../source/proofs/pluscomm.rst:64 3d6b3dc2c0cc466cba382385590a2ce8
msgid "We have a *type* for propositional equality here, and correspondingly a *program* inhabiting an instance of this type can be seen as a proof of the corresponding proposition [1]_. So, trivially, we can prove that ``4`` equals ``4``:"
msgstr "这里我们有一个命题等式的*类型*，相应地，实例化该类型的*程序*可以视为对应命题的证明 [1]_。因此，我们可以轻松证明 ``4`` 等于 ``4``："

#: ../source/proofs/pluscomm.rst:74 e407ede6d71740eaacb11a30a1850fa5
msgid "However, trying to prove that ``4 = 5`` results in failure:"
msgstr "然而，尝试证明 ``4 = 5`` 会失败："

#: ../source/proofs/pluscomm.rst:81 aa9dfd4b69be4cf98c2a0f03b70cb061
msgid "The type ``4 = 5`` is a perfectly valid type, but is uninhabited, so when trying to type check this definition, Idris gives the following error:"
msgstr "类型 ``4 = 5`` 是一个完全有效的类型，但它是不可实例化的，因此在类型检查该定义时，Idris 会报如下错误："

#: ../source/proofs/pluscomm.rst:94 907550e2c9624f6f89d59d40bc229a3f
msgid "Type checking equality proofs"
msgstr "等式证明的类型检查（Type checking equality proofs）"

#: ../source/proofs/pluscomm.rst:96 98d42f6ebebb4d36adb67c589b6a3bd9
msgid "An important step in type checking Idris programs is *unification*, which attempts to resolve implicit arguments such as the implicit argument ``x`` in ``Refl``. As far as our understanding of type checking proofs is concerned, it suffices to know that unifying two terms involves reducing both to normal form then trying to find an assignment to implicit arguments which will make those normal forms equal."
msgstr "在 Idris 程序的类型检查中，一个重要步骤是*统一（unification）*，它尝试解析隐式参数，比如 ``Refl`` 中的隐式参数 ``x``。就我们对类型检查证明的理解而言，只需知道统一两个项的过程是将它们都归约为正常形（normal form），然后尝试为隐式参数赋值，使得这两个正常形相等。"

#: ../source/proofs/pluscomm.rst:103 1c5c8108090249fcb885ad911c6bddad
msgid "When type checking ``Refl``, Idris requires that the type is of the form ``x = x``, as we see from the type of ``Refl``. In the case of ``four_eq_five``, Idris will try to unify the expected type ``4 = 5`` with the type of ``Refl``, ``x = x``, notice that a solution requires that ``x`` be both ``4`` and ``5``, and therefore fail."
msgstr "在类型检查 ``Refl`` 时，Idris 要求类型必须是 ``x = x`` 的形式，这可以从 ``Refl`` 的类型看出。对于 ``four_eq_five``，Idris 会尝试将期望类型 ``4 = 5`` 与 ``Refl`` 的类型 ``x = x`` 统一，注意到要有解就要求 ``x`` 同时为 ``4`` 和 ``5``，因此会失败。"

#: ../source/proofs/pluscomm.rst:109 60c4c9f5e0e74677baa6b29d02736df7
msgid "Since type checking involves reduction to normal form, we can write the following equalities directly:"
msgstr "由于类型检查会归约到正常形，我们可以直接写出如下等式："

#: ../source/proofs/pluscomm.rst:124 cdf97ce053bd4cc8b09fad7d1f4d95a9
msgid "Heterogeneous Equality"
msgstr "异类等式（Heterogeneous Equality）"

#: ../source/proofs/pluscomm.rst:126 f29d4bfe1ee94d01bfba1b2aec28d6ef
msgid "Equality in Idris is *heterogeneous*, meaning that we can even propose equalities between values in different types:"
msgstr "Idris 中的等式是*异类*的，这意味着我们甚至可以提出不同类型值之间的等式："

#: ../source/proofs/pluscomm.rst:133 f48bccba5b1241349c4b57b4b8865b7f
msgid "The type ``Z = \"Z\"`` is uninhabited, and one might wonder why it is useful to be able to propose equalities between values in different types. However, with dependent types, such equalities can arise naturally. For example, if two vectors are equal, their lengths must be equal:"
msgstr "类型 ``Z = \"Z\"`` 是不可实例化的，有人可能会疑惑为什么要提出不同类型值之间的等式。然而，在依赖类型（dependent types）中，这类等式会自然出现。例如，如果两个向量相等，那么它们的长度也必须相等："

#: ../source/proofs/pluscomm.rst:143 958154022d1b4ce48dcb1fb83ceebaa9
msgid "In the above declaration, ``xs`` and ``ys`` have different types because their lengths are different, but we would still like to draw a conclusion about the lengths if they happen to be equal. We can define ``vect_eq_length`` as follows:"
msgstr "在上述声明中，``xs`` 和 ``ys`` 因长度不同而类型不同，但如果它们相等，我们仍希望得出关于长度的结论。我们可以如下定义 ``vect_eq_length``："

#: ../source/proofs/pluscomm.rst:152 6451b658602443b0b4f75e1c40c5c03d
msgid "By matching on ``Refl`` for the third argument, we know that the only valid value for ``ys`` is ``xs``, because they must be equal, and therefore their types must be equal, so the lengths must be equal."
msgstr "通过对第三个参数使用 ``Refl`` 进行模式匹配，我们知道 ``ys`` 唯一有效的取值就是 ``xs``，因为它们必须相等，因此类型也必须相等，所以长度也必须相等。"

#: ../source/proofs/pluscomm.rst:156 134aa210543243708d94f1571a94453d
msgid "Alternatively, we can put an underscore for the second ``xs``, since there is only one value which will type check:"
msgstr "或者，我们可以将第二个 ``xs`` 用下划线代替，因为只有一个值能通过类型检查："

#: ../source/proofs/pluscomm.rst:164 dd91dd3c9ccb4b6f94470bcc1d042e68
msgid "Properties of ``plus``"
msgstr "``plus`` 的性质（Properties of plus）"

#: ../source/proofs/pluscomm.rst:166 61eed8640046486a9842af86d1b02d93
msgid "Using the ``(=)`` type, we can now state the properties of ``plus`` given above as Idris type declarations:"
msgstr "利用 ``(=)`` 类型，我们现在可以将上述 ``plus`` 的性质写成 Idris 类型声明："

#: ../source/proofs/pluscomm.rst:174 50412191002943288d043581f472a5e0
msgid "Both of these properties (and many others) are proved for natural number addition in the Idris standard library, using ``(+)`` from the ``Num`` interface rather than using ``plus`` directly. They have the names ``plusCommutative`` and ``plusAssociative`` respectively."
msgstr "这两个性质（以及许多其他性质）在 Idris 标准库中都已针对自然数加法被证明，使用的是 ``Num`` 接口中的 ``(+)``，而不是直接用 ``plus``。它们分别被命名为 ``plusCommutative`` 和 ``plusAssociative``。"

#: ../source/proofs/pluscomm.rst:179 e2b43c9848e24afb943f2392be5c7705
msgid "In the remainder of this tutorial, we will explore several different ways of proving ``plus_commutes`` (or, to put it another way, writing the function.) We will also discuss how to use such equality proofs, and see where the need for them arises in practice."
msgstr "在本教程的后续部分，我们将探讨多种证明 ``plus_commutes`` 的方法（换句话说，也就是编写该函数）。我们还会讨论如何使用这些等式证明，并了解实际中何时需要它们。"

#: ../source/proofs/pluscomm.rst:185 6ec81014577848c6b2c9e6bcc83fee22
msgid "This is known as the Curry-Howard correspondence."
msgstr "这被称为 Curry-Howard 对应（Curry-Howard correspondence）。"
